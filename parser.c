#include <stdio.h>
#include <stdlib.h>

#include "parser.h"
#include "front.h"

static void error();

/**
 * This is the example Recursive-Descent Parser in pp. 181 - 185 in the 
 * textbook 
 *
 * Sebesta, R. W. (2012). Concepts of Programming Languages. 
 * Pearson, 10th edition.
 *
 *
 * */

/* NEW -- pro(program) 
*  parses the rule:
*  P::= S
*  checks for S;S rule
*/
void pro() {
    sent();
    // checks for S;S rule
    while (nextToken == SEMICOLON) {
        lex();
        sent();
    }
    // checks for S rule violation
    if (!(nextToken == EOF)) {
        error();
    }
    // prints Syntax Validated if no rules violated
    // exit code 0
    else if (nextToken == EOF) {
        printf("Syntax Validated");
        exit(0);
    }
}

/* NEW -- sent(sentence)
*  parses by the rule:
*  S ::= V:=E | read(V) | write(E) | if C: then S fi | if C: then S else S fi | S;S
*/
void sent() {
    // V:=E
    if (nextToken == IDENT) {
        lex();
        if (nextToken == ASSIGN_OP) {
            lex();
            expr();
            
        }
        else
            error();
    }
    // read(V)
    else if (nextToken == KEY_READ) {
        lex();
        if (nextToken == LEFT_PAREN) {
            lex();
            if (nextToken == IDENT) {
                lex();
                if (nextToken == RIGHT_PAREN) {
                    lex();
                }
                else
                    error();
            }
            else
                error();
        }
        else
            error();
    }
    // write(E)
    else if (nextToken == KEY_WRITE) {
        lex();
        if (nextToken == LEFT_PAREN) {
            lex();
            expr();
            if (nextToken == RIGHT_PAREN) {
                lex();
            }
            else
                error();
        }
        else
            error();
    }
    // if C: then S fi && if C: then S U fi
    // if
    else if (nextToken == KEY_IF) {
        lex();
        // C
        comp();
        // :
        if (nextToken == COLON) {
            lex();
            // then
            if (nextToken == KEY_THEN) {
                lex();
                // S
                sent();
                // checks for S;S rule
                while (nextToken == SEMICOLON) {
                    lex();
                    sent();
                }
                // call u to check for else statement
                u();
                // fi
                if (nextToken == KEY_FI) {
                    lex(); 
                }
                else
                    error(); 
            }
            else
                error();
        }
        else
            error();
    }
    // error if nothing is true
    else
        error();
}

/* NEW -- u(else)
*  parses the rule:
*  if C: then S else S fi
*/
void u() {
    if (nextToken == KEY_ELSE) {
        lex();
        sent();
        // checks for S;S rule
        while (nextToken == SEMICOLON) {
            lex();
            sent();
        }
    }
}

/* NEW -- comp(compare)
*  parses rule: 
*  C ::=  ( C ) | E < E | E > E | E = E | E <> E | E <= E | E >= E
*/
void comp() {
    // (C)
    if (nextToken == LEFT_PAREN) {
        lex();
        comp();
        if (nextToken == RIGHT_PAREN) {
            lex();
        }
        else
            error();
    }
    // everything else
    else {
        expr();
        if (nextToken == LESSER_OP || GREATER_OP || EQUAL_OP || NEQUAL_OP || LEQUAL_OP || GEQUAL_OP) {
            lex();
            expr();
        }
        else
            error();
    }
}

/* expr
 * Parses strings in the language generated by the rule:
 * <expr> -> <term> {(+ | -) <term>}
 */
void expr() 
{
    /* Parse the first term */
    term();

    /* As long as the next token is + or -, get
    the next token and parse the next term */
    while (nextToken == ADD_OP || nextToken == SUB_OP) {
        lex();
        term();
    }
} 

/* term
 * Parses strings in the language generated by the rule:
 * <term> -> <factor> {(* | /) <factor>)
 */
void term() 
{
    /* Parse the first factor */
    factor();
    /* As long as the next token is * or / or %, get the
    next token and parse the next factor */
    while (nextToken == MULT_OP || nextToken == DIV_OP || nextToken == MOD_OP) {
            lex();
            factor();
    }
} 

/* factor
 * Parses strings in the language generated by the rule:
 * <factor> -> id | int_constant | ( <expr )
 * */
void factor() 
{
    /* Determine which RHS */
    if (nextToken == IDENT || nextToken == INT_LIT) {
        lex(); /* Get the next token */
    } 
    /* If the RHS is (<expr>), call lex to pass over the
        left parenthesis, call expr, and check for the right
        parenthesis */
    else if (nextToken == LEFT_PAREN) {
        lex();
        expr();

        if (nextToken == RIGHT_PAREN) {
            lex();
        }
        else {
            error();
        }
    }
    else if (nextToken == INC_OP || DEC_OP) {
        lex();
        if (nextToken == IDENT) {
            lex();
        }
        else
            error();
    }
        /* End of if (nextToken == ... */
        /* It was not an id, an integer literal, or a left parenthesis */
        else 
        { 
            error(); 
        }
} 

/* error function
*  called when lexeme does not match the expected nextToken
*  exit code 1
*/
static void error() 
{
    lex();
    printf("Error encounterer: The next lexeme was %s and the next token was %d", lexeme, nextToken);
    exit(1);
}
